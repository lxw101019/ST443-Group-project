confusion$FP <- confusion$FP + 1
}
}
} else if (estimate_way == 'both') {
if (true_edge[i,j] == TRUE){
if (estimate_edge[i,j] == TRUE & estimate_edge[j,i] == TRUE){
confusion$TP <- confusion$TP + 1
} else {
confusion$FN <- confusion$FN + 1
}
} else {
if (estimate_edge[i,j] == TRUE & estimate_edge[j,i] == TRUE){
confusion$FP <- confusion$FP + 1
} else {
confusion$TN <- confusion$TN + 1
}
}
}
}
}
TP_rate <- confusion$TP/(confusion$TP + confusion$FN)
FP_rate <- confusion$FP/(confusion$FP + confusion$TN)
return(confusion)
}
ROC_curve(data,theta,"both")
ROC_curve <- function(data_set, theta, estimate_way, how_many_lambda_in_roc = 100){
numOfDims <- ncol(data_set)
print(numOfDims)
max_lambda = 1
min_lambda = 0
points <- data.frame(matrix(ncol = 3, nrow = how_many_lambda_in_roc))
for (i in seq(numOfDims)){
y <- (data_set[,i])
x <- (data_set[,-c(i)])
lasso.train <-glmnet(x, y)
if (lasso.train$lambda[1]>max_lambda){
max_lambda <- lasso.train$lambda[1]
}
if (lasso.train$lambda[length(lasso.train$lambda)]<min_lambda){
min_lambda <- lasso.train$lambda[length(lasso.train$lambda)]
}
}
print(max_lambda)
print(min_lambda)
lambda_seq <- seq(from = min_lambda, to = max_lambda, length.out= how_many_lambda_in_roc)
true_edge <- true_edge(theta)
for (i in seq(length(lambda_seq))){
estimate_edge <- edge_table(data_set, lambda_seq[i])
confusion <- confusion_matrix(estimate_edge, true_edge, estimate_way)
TPR <- confusion$TP_rate
FPR <- confusion$FP_rate
points[i,1] <- TPR
points[i,2] <- FPR
}
colnames(points) <- c("TPR","FPR","Lambda")
return(points)
}
ROC_curve(data,theta,"both")
ROC_curve <- function(data_set, theta, estimate_way, how_many_lambda_in_roc = 100){
numOfDims <- ncol(data_set)
print(numOfDims)
max_lambda = 1
min_lambda = 0
points <- data.frame(matrix(ncol = 3, nrow = how_many_lambda_in_roc))
for (i in seq(numOfDims)){
y <- (data_set[,i])
x <- (data_set[,-c(i)])
lasso.train <-glmnet(x, y)
if (lasso.train$lambda[1]>max_lambda){
max_lambda <- lasso.train$lambda[1]
}
if (lasso.train$lambda[length(lasso.train$lambda)]<min_lambda){
min_lambda <- lasso.train$lambda[length(lasso.train$lambda)]
}
}
print(max_lambda)
print(min_lambda)
lambda_seq <- seq(from = min_lambda, to = max_lambda, length.out= how_many_lambda_in_roc)
print(lambda_seq)
true_edge <- true_edge(theta)
for (i in seq(length(lambda_seq))){
estimate_edge <- edge_table(data_set, lambda_seq[i])
confusion <- confusion_matrix(estimate_edge, true_edge, estimate_way)
TPR <- confusion$TP_rate
FPR <- confusion$FP_rate
points[i,1] <- TPR
points[i,2] <- FPR
}
colnames(points) <- c("TPR","FPR","Lambda")
return(points)
}
ROC_curve(data,theta,"both")
print(estimate_edge)
ROC_curve <- function(data_set, theta, estimate_way, how_many_lambda_in_roc = 100){
numOfDims <- ncol(data_set)
print(numOfDims)
max_lambda = 1
min_lambda = 0
points <- data.frame(matrix(ncol = 3, nrow = how_many_lambda_in_roc))
for (i in seq(numOfDims)){
y <- (data_set[,i])
x <- (data_set[,-c(i)])
lasso.train <-glmnet(x, y)
if (lasso.train$lambda[1]>max_lambda){
max_lambda <- lasso.train$lambda[1]
}
if (lasso.train$lambda[length(lasso.train$lambda)]<min_lambda){
min_lambda <- lasso.train$lambda[length(lasso.train$lambda)]
}
}
print(max_lambda)
print(min_lambda)
lambda_seq <- seq(from = min_lambda, to = max_lambda, length.out= how_many_lambda_in_roc)
print(lambda_seq)
true_edge <- true_edge(theta)
for (i in seq(length(lambda_seq))){
estimate_edge <- edge_table(data_set, lambda_seq[i])
print(estimate_edge)
confusion <- confusion_matrix(estimate_edge, true_edge, estimate_way)
TPR <- confusion$TP_rate
FPR <- confusion$FP_rate
points[i,1] <- TPR
points[i,2] <- FPR
}
colnames(points) <- c("TPR","FPR","Lambda")
return(points)
}
ROC_curve(data,theta,"both")
ROC_curve <- function(data_set, theta, estimate_way, how_many_lambda_in_roc = 100){
numOfDims <- ncol(data_set)
print(numOfDims)
max_lambda = 1
min_lambda = 0
points <- data.frame(matrix(ncol = 3, nrow = how_many_lambda_in_roc))
for (i in seq(numOfDims)){
y <- (data_set[,i])
x <- (data_set[,-c(i)])
lasso.train <-glmnet(x, y)
if (lasso.train$lambda[1]>max_lambda){
max_lambda <- lasso.train$lambda[1]
}
if (lasso.train$lambda[length(lasso.train$lambda)]<min_lambda){
min_lambda <- lasso.train$lambda[length(lasso.train$lambda)]
}
}
print(max_lambda)
print(min_lambda)
lambda_seq <- seq(from = min_lambda, to = max_lambda, length.out= how_many_lambda_in_roc)
print(lambda_seq)
true_edge <- true_edge(theta)
for (i in seq(length(lambda_seq))){
estimate_edge <- edge_table(data_set, lambda_seq[i])
#print(estimate_edge)
confusion <- confusion_matrix(estimate_edge, true_edge, estimate_way)
print(confusion)
TPR <- confusion$TP_rate
FPR <- confusion$FP_rate
points[i,1] <- TPR
points[i,2] <- FPR
}
colnames(points) <- c("TPR","FPR","Lambda")
return(points)
}
ROC_curve(data,theta,"both")
ROC_curve <- function(data_set, theta, estimate_way, how_many_lambda_in_roc = 100){
numOfDims <- ncol(data_set)
print(numOfDims)
max_lambda = 1
min_lambda = 0
points <- data.frame(matrix(ncol = 3, nrow = how_many_lambda_in_roc))
for (i in seq(numOfDims)){
y <- (data_set[,i])
x <- (data_set[,-c(i)])
lasso.train <-glmnet(x, y)
if (lasso.train$lambda[1]>max_lambda){
max_lambda <- lasso.train$lambda[1]
}
if (lasso.train$lambda[length(lasso.train$lambda)]<min_lambda){
min_lambda <- lasso.train$lambda[length(lasso.train$lambda)]
}
}
print(max_lambda)
print(min_lambda)
lambda_seq <- seq(from = min_lambda, to = max_lambda, length.out= how_many_lambda_in_roc)
print(lambda_seq)
true_edge <- true_edge(theta)
for (i in seq(length(lambda_seq))){
estimate_edge <- edge_table(data_set, lambda_seq[i])
#print(estimate_edge)
confusion <- confusion_matrix(estimate_edge, true_edge, estimate_way)
#print(confusion)
TPR <- confusion$TP_rate
FPR <- confusion$FP_rate
print(TPR)
print(FPR)
points[i,1] <- TPR
points[i,2] <- FPR
}
colnames(points) <- c("TPR","FPR","Lambda")
return(points)
}
ROC_curve(data,theta,"both")
ROC_curve <- function(data_set, theta, estimate_way, how_many_lambda_in_roc = 100){
numOfDims <- ncol(data_set)
print(numOfDims)
max_lambda = 1
min_lambda = 0
points <- data.frame(matrix(ncol = 3, nrow = how_many_lambda_in_roc))
for (i in seq(numOfDims)){
y <- (data_set[,i])
x <- (data_set[,-c(i)])
lasso.train <-glmnet(x, y)
if (lasso.train$lambda[1]>max_lambda){
max_lambda <- lasso.train$lambda[1]
}
if (lasso.train$lambda[length(lasso.train$lambda)]<min_lambda){
min_lambda <- lasso.train$lambda[length(lasso.train$lambda)]
}
}
print(max_lambda)
print(min_lambda)
lambda_seq <- seq(from = min_lambda, to = max_lambda, length.out= how_many_lambda_in_roc)
print(lambda_seq)
true_edge <- true_edge(theta)
for (i in seq(length(lambda_seq))){
estimate_edge <- edge_table(data_set, lambda_seq[i])
#print(estimate_edge)
confusion <- confusion_matrix(estimate_edge, true_edge, estimate_way)
print(confusion)
TPR <- confusion$TP_rate
FPR <- confusion$FP_rate
#print(TPR)
#print(FPR)
points[i,1] <- TPR
points[i,2] <- FPR
}
colnames(points) <- c("TPR","FPR","Lambda")
return(points)
}
ROC_curve(data,theta,"both")
# This is the code for generating confusion matrix/ROC curve point based on given edtimated edge table and true edge table.
#
# Arguments:1. estimate_edge: the TRUE/FALSE table from edgetable.R
#           2. true_edge: the TRUE/FALSE table from True_edge.R
#           3. estimate_way: input 'both' or 'either' here. 'both' stands for E_1 estimator. 'either' stands for E_2 estimator.
#
# Retutn: 1.confusion: a list. Use list$TP/FP/FN/TN/TP_rate/FP_rate to get each confusion element or ROC curve point
#
confusion_matrix <- function(estimate_edge, true_edge, estimate_way){
numOfDims <- nrow(estimate_edge)
confusion <- list(TP = 0,FP = 0,FN = 0,TN = 0,TP_rate = 0,FP_rate = 0)
for (i in seq(numOfDims)){
for (j in seq(numOfDims)[seq(numOfDims)>i]){
if (estimate_way == 'either'){
if (true_edge[i,j] == TRUE){
if (estimate_edge[i,j] == FALSE & estimate_edge[j,i] == FALSE){
confusion$FN <- confusion$FN + 1
} else {
confusion$TP <- confusion$TP + 1
}
} else {
if (estimate_edge[i,j] == FALSE & estimate_edge[j,i] == FALSE){
confusion$TN <- confusion$TN + 1
} else {
confusion$FP <- confusion$FP + 1
}
}
} else if (estimate_way == 'both') {
if (true_edge[i,j] == TRUE){
if (estimate_edge[i,j] == TRUE & estimate_edge[j,i] == TRUE){
confusion$TP <- confusion$TP + 1
} else {
confusion$FN <- confusion$FN + 1
}
} else {
if (estimate_edge[i,j] == TRUE & estimate_edge[j,i] == TRUE){
confusion$FP <- confusion$FP + 1
} else {
confusion$TN <- confusion$TN + 1
}
}
}
}
}
confusion$TP_rate <- confusion$TP/(confusion$TP + confusion$FN)
confusion$FP_rate <- confusion$FP/(confusion$FP + confusion$TN)
return(confusion)
}
ROC_curve <- function(data_set, theta, estimate_way, how_many_lambda_in_roc = 100){
numOfDims <- ncol(data_set)
print(numOfDims)
max_lambda = 1
min_lambda = 0
points <- data.frame(matrix(ncol = 3, nrow = how_many_lambda_in_roc))
for (i in seq(numOfDims)){
y <- (data_set[,i])
x <- (data_set[,-c(i)])
lasso.train <-glmnet(x, y)
if (lasso.train$lambda[1]>max_lambda){
max_lambda <- lasso.train$lambda[1]
}
if (lasso.train$lambda[length(lasso.train$lambda)]<min_lambda){
min_lambda <- lasso.train$lambda[length(lasso.train$lambda)]
}
}
print(max_lambda)
print(min_lambda)
lambda_seq <- seq(from = min_lambda, to = max_lambda, length.out= how_many_lambda_in_roc)
print(lambda_seq)
true_edge <- true_edge(theta)
for (i in seq(length(lambda_seq))){
estimate_edge <- edge_table(data_set, lambda_seq[i])
#print(estimate_edge)
confusion <- confusion_matrix(estimate_edge, true_edge, estimate_way)
#print(confusion)
TPR <- confusion$TP_rate
FPR <- confusion$FP_rate
#print(TPR)
#print(FPR)
points[i,1] <- TPR
points[i,2] <- FPR
}
colnames(points) <- c("TPR","FPR","Lambda")
return(points)
}
ROC_curve(data,theta,"both")
ROC_curve <- function(data_set, theta, estimate_way, how_many_lambda_in_roc = 100){
numOfDims <- ncol(data_set)
print(numOfDims)
max_lambda = 1
min_lambda = 0
points <- data.frame(matrix(ncol = 3, nrow = how_many_lambda_in_roc))
for (i in seq(numOfDims)){
y <- (data_set[,i])
x <- (data_set[,-c(i)])
lasso.train <-glmnet(x, y)
if (lasso.train$lambda[1]>max_lambda){
max_lambda <- lasso.train$lambda[1]
}
if (lasso.train$lambda[length(lasso.train$lambda)]<min_lambda){
min_lambda <- lasso.train$lambda[length(lasso.train$lambda)]
}
}
#print(max_lambda)
#print(min_lambda)
lambda_seq <- seq(from = min_lambda, to = max_lambda, length.out= how_many_lambda_in_roc)
#print(lambda_seq)
points[,3] <- lambda_seq
true_edge <- true_edge(theta)
for (i in seq(length(lambda_seq))){
estimate_edge <- edge_table(data_set, lambda_seq[i])
#print(estimate_edge)
confusion <- confusion_matrix(estimate_edge, true_edge, estimate_way)
#print(confusion)
TPR <- confusion$TP_rate
FPR <- confusion$FP_rate
#print(TPR)
#print(FPR)
points[i,1] <- TPR
points[i,2] <- FPR
}
colnames(points) <- c("TPR","FPR","Lambda")
return(points)
}
ROC_curve(data,theta,"both")
choose_best_lambda(data)
# Lin:
# This is the code for choosing best lambda based on the simulation data
#
# Arguments:1. data: In this case we input the simulation data
#
#
# Retutn: 1.final: which is the best lambda,in each case of making X_i as response, there will be a lambda that minimised the test error.
#                  In this case, the best lambda 'final' is the mean of these lambda. Further discussion needed here.
choose_best_lambda <- function(data){
library(glmnet)
numOfRows <- nrow(data)
numOfDims <- ncol(data)
lambda.best_list = rep(0,numOfDims)
for (i in seq(numOfDims)){
y <- (testdata[,i])
x <- (testdata[,-c(i)])
train <-sample(seq(numOfRows), 0.7*numOfRows, replace=FALSE)
lasso.train <-glmnet(x[train,], y[train])
pred.test <-predict(lasso.train, x[-train,])
rmse <-sqrt(apply((y[-train]-pred.test)^2,2,mean))
lambda.best <-lasso.train$lambda[order(rmse)[1]]
lambda.best_list[i] <- lambda.best
}
final <- mean(lambda.best_list)
return(final)
}
choose_best_lambda(data)
# Lin:
# This is the code for choosing best lambda based on the simulation data
#
# Arguments:1. data: In this case we input the simulation data
#
#
# Retutn: 1.final: which is the best lambda,in each case of making X_i as response, there will be a lambda that minimised the test error.
#                  In this case, the best lambda 'final' is the mean of these lambda. Further discussion needed here.
choose_best_lambda <- function(data){
library(glmnet)
numOfRows <- nrow(data)
numOfDims <- ncol(data)
lambda.best_list = rep(0,numOfDims)
for (i in seq(numOfDims)){
y <- (data[,i])
x <- (data[,-c(i)])
train <-sample(seq(numOfRows), 0.7*numOfRows, replace=FALSE)
lasso.train <-glmnet(x[train,], y[train])
pred.test <-predict(lasso.train, x[-train,])
rmse <-sqrt(apply((y[-train]-pred.test)^2,2,mean))
lambda.best <-lasso.train$lambda[order(rmse)[1]]
lambda.best_list[i] <- lambda.best
}
final <- mean(lambda.best_list)
return(final)
}
choose_best_lambda(data)
ROC_curve(data,theta,"either")
ROC_curve <- function(data_set, theta, estimate_way, how_many_lambda_in_roc = 100){
library(ggplot2)
numOfDims <- ncol(data_set)
print(numOfDims)
max_lambda = 1
min_lambda = 0
points <- data.frame(matrix(ncol = 3, nrow = how_many_lambda_in_roc))
for (i in seq(numOfDims)){
y <- (data_set[,i])
x <- (data_set[,-c(i)])
lasso.train <-glmnet(x, y)
if (lasso.train$lambda[1]>max_lambda){
max_lambda <- lasso.train$lambda[1]
}
if (lasso.train$lambda[length(lasso.train$lambda)]<min_lambda){
min_lambda <- lasso.train$lambda[length(lasso.train$lambda)]
}
}
#print(max_lambda)
#print(min_lambda)
lambda_seq <- seq(from = min_lambda, to = max_lambda, length.out= how_many_lambda_in_roc)
#print(lambda_seq)
points[,3] <- lambda_seq
true_edge <- true_edge(theta)
for (i in seq(length(lambda_seq))){
estimate_edge <- edge_table(data_set, lambda_seq[i])
#print(estimate_edge)
confusion <- confusion_matrix(estimate_edge, true_edge, estimate_way)
#print(confusion)
TPR <- confusion$TP_rate
FPR <- confusion$FP_rate
#print(TPR)
#print(FPR)
points[i,1] <- TPR
points[i,2] <- FPR
}
colnames(points) <- c("TPR","FPR","Lambda")
ggplot(points, aes(FPR, TPR)) + geom_step()
return(points)
}
ROC_curve(data,theta,"either")
ROC_curve <- function(data_set, theta, estimate_way, how_many_lambda_in_roc = 100){
library(ggplot2)
numOfDims <- ncol(data_set)
print(numOfDims)
max_lambda = 1
min_lambda = 0
points <- data.frame(matrix(ncol = 3, nrow = how_many_lambda_in_roc))
for (i in seq(numOfDims)){
y <- (data_set[,i])
x <- (data_set[,-c(i)])
lasso.train <-glmnet(x, y)
if (lasso.train$lambda[1]>max_lambda){
max_lambda <- lasso.train$lambda[1]
}
if (lasso.train$lambda[length(lasso.train$lambda)]<min_lambda){
min_lambda <- lasso.train$lambda[length(lasso.train$lambda)]
}
}
#print(max_lambda)
#print(min_lambda)
lambda_seq <- seq(from = min_lambda, to = max_lambda, length.out= how_many_lambda_in_roc)
#print(lambda_seq)
points[,3] <- lambda_seq
true_edge <- true_edge(theta)
for (i in seq(length(lambda_seq))){
estimate_edge <- edge_table(data_set, lambda_seq[i])
#print(estimate_edge)
confusion <- confusion_matrix(estimate_edge, true_edge, estimate_way)
#print(confusion)
TPR <- confusion$TP_rate
FPR <- confusion$FP_rate
#print(TPR)
#print(FPR)
points[i,1] <- TPR
points[i,2] <- FPR
}
colnames(points) <- c("TPR","FPR","Lambda")
ggplot(points, aes(FPR, TPR)) + geom_step()
return(points)
}
ROC_curve(data,theta,"either")
testtest <- ROC_curve(data,theta,"either")
ggplot(testtest, aes(FPR, TPR)) + geom_step()
testdata <- simulation(100,1000)
data <- testdata$data
theta <- testdata$standardtheta
View(theta)
View(data)
testtest <- ROC_curve(data,theta,"either")
ggplot(testtest, aes(FPR, TPR)) + geom_step()
