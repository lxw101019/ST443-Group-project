# Arguments:1. data: In this case we input the simulation data
#
#
# Retutn: 1.final: which is the best lambda,in each case of making X_i as response, there will be a lambda that minimised the test error.
#                  In this case, the best lambda 'final' is the mean of these lambda. Further discussion needed here.
choose_best_lambda <- function(data){
library(glmnet)
numOfRows <- nrow(data)
numOfDims <- ncol(data)
lambda.best_list = rep(0,numOfDims)
for (i in seq(numOfDims)){
y <- (data[,i])
x <- (data[,-c(i)])
train <-sample(seq(numOfRows), 0.7*numOfRows, replace=FALSE)
lasso.train <-glmnet(x[train,], y[train])
pred.test <-predict(lasso.train, x[-train,])
rmse <-sqrt(apply((y[-train]-pred.test)^2,2,mean))
lambda.best <-lasso.train$lambda[order(rmse)[1]]
lambda.best_list[i] <- lambda.best
}
final <- mean(lambda.best_list)
return(final)
}
lambda_MINTESTERROR <- choose_best_lambda(testdata)
estimateedge <- edge_table(testdata, lambda_MINTESTERROR)
edge_table <- function(data_set, lambda_choice){
numOfRows <- nrow(data_set)
numOfDims <- ncol(data_set)
edge <- data.frame(matrix(ncol = numOfDims, nrow = numOfDims))
for (i in seq(numOfDims)){
y <- (data_set[,i])
x <- (data_set[,-c(i)])
coeff <- coef(glmnet(x,y, lambda=lambda_choice))
coeff <- as.matrix(coeff)[-c(1)]
coeff <- append(coeff, 1, after= i-1)
edge[i,] <- coeff
}
tf <- data.frame(lapply(edge, function(x) {x!=0}))
colnames(tf) <- seq(numOfDims)
return(tf)
}
table <- confusion_matrix(estimate_edge, true_edge, "either")
# This is the code for generating confusion matrix/ROC curve point based on given edtimated edge table and true edge table.
#
# Arguments:1. estimate_edge: the TRUE/FALSE table from edgetable.R
#           2. trueEdge: the TRUE/FALSE table from trueEdge.R
#           3. estimate_way: input 'both' or 'either' here. 'both' stands for E_1 estimator. 'either' stands for E_2 estimator.
#
# Retutn: 1.confusion: a list. Use list$TP/FP/FN/TN/TP_rate/FP_rate to get each confusion element or ROC curve point
#
confusion_matrix <- function(estimate_edge, trueEdge, estimate_way){
numOfDims <- nrow(estimate_edge)
confusion <- list(TP = 0,FP = 0,FN = 0,TN = 0,TP_rate = 0,FP_rate = 0)
for (i in seq(numOfDims-1)){
for (j in seq(numOfDims)[seq(numOfDims)>i]){
if (estimate_way == 'either'){
if (trueEdge[i,j] == TRUE){
if (estimate_edge[i,j] == FALSE & estimate_edge[j,i] == FALSE){
confusion$FN <- confusion$FN + 1
} else {
confusion$TP <- confusion$TP + 1
}
} else {
if (estimate_edge[i,j] == FALSE & estimate_edge[j,i] == FALSE){
confusion$TN <- confusion$TN + 1
} else {
confusion$FP <- confusion$FP + 1
}
}
} else if (estimate_way == 'both') {
if (trueEdge[i,j] == TRUE){
if (estimate_edge[i,j] == TRUE & estimate_edge[j,i] == TRUE){
confusion$TP <- confusion$TP + 1
} else {
confusion$FN <- confusion$FN + 1
}
} else {
if (estimate_edge[i,j] == TRUE & estimate_edge[j,i] == TRUE){
confusion$FP <- confusion$FP + 1
} else {
confusion$TN <- confusion$TN + 1
}
}
}
}
}
confusion$TP_rate <- confusion$TP/(confusion$TP + confusion$FN)
confusion$FP_rate <- confusion$FP/(confusion$FP + confusion$TN)
return(confusion)
}
table <- confusion_matrix(estimate_edge, true_edge, "either")
estimate_edge <- edge_table(testdata, lambda_MINTESTERROR)
table <- confusion_matrix(estimate_edge, true_edge, "either")
trueedge <- true_edge(testtheta)
View(trueedge)
# This is the code for generating confusion matrix/ROC curve point based on given edtimated edge table and true edge table.
#
# Arguments:1. estimate_edge: the TRUE/FALSE table from edgetable.R
#           2. trueEdge: the TRUE/FALSE table from trueEdge.R
#           3. estimate_way: input 'both' or 'either' here. 'both' stands for E_1 estimator. 'either' stands for E_2 estimator.
#
# Retutn: 1.confusion: a list. Use list$TP/FP/FN/TN/TP_rate/FP_rate to get each confusion element or ROC curve point
#
confusion_matrix <- function(estimate_edge, trueEdge, estimate_way){
numOfDims <- nrow(estimate_edge)
confusion <- list(TP = 0,FP = 0,FN = 0,TN = 0,TP_rate = 0,FP_rate = 0)
for (i in seq(numOfDims-1)){
for (j in seq(numOfDims)[seq(numOfDims)>i]){
print(i)
print(j)
if (estimate_way == 'either'){
if (trueEdge[i,j] == TRUE){
if (estimate_edge[i,j] == FALSE & estimate_edge[j,i] == FALSE){
confusion$FN <- confusion$FN + 1
} else {
confusion$TP <- confusion$TP + 1
}
} else {
if (estimate_edge[i,j] == FALSE & estimate_edge[j,i] == FALSE){
confusion$TN <- confusion$TN + 1
} else {
confusion$FP <- confusion$FP + 1
}
}
} else if (estimate_way == 'both') {
if (trueEdge[i,j] == TRUE){
if (estimate_edge[i,j] == TRUE & estimate_edge[j,i] == TRUE){
confusion$TP <- confusion$TP + 1
} else {
confusion$FN <- confusion$FN + 1
}
} else {
if (estimate_edge[i,j] == TRUE & estimate_edge[j,i] == TRUE){
confusion$FP <- confusion$FP + 1
} else {
confusion$TN <- confusion$TN + 1
}
}
}
}
}
confusion$TP_rate <- confusion$TP/(confusion$TP + confusion$FN)
confusion$FP_rate <- confusion$FP/(confusion$FP + confusion$TN)
return(confusion)
}
table <- confusion_matrix(estimate_edge, true_edge, "either")
print(seq(numOfDims)[seq(numOfDims)>i])
# This is the code for generating confusion matrix/ROC curve point based on given edtimated edge table and true edge table.
#
# Arguments:1. estimate_edge: the TRUE/FALSE table from edgetable.R
#           2. trueEdge: the TRUE/FALSE table from trueEdge.R
#           3. estimate_way: input 'both' or 'either' here. 'both' stands for E_1 estimator. 'either' stands for E_2 estimator.
#
# Retutn: 1.confusion: a list. Use list$TP/FP/FN/TN/TP_rate/FP_rate to get each confusion element or ROC curve point
#
confusion_matrix <- function(estimate_edge, trueEdge, estimate_way){
numOfDims <- nrow(estimate_edge)
confusion <- list(TP = 0,FP = 0,FN = 0,TN = 0,TP_rate = 0,FP_rate = 0)
for (i in seq(numOfDims-1)){
for (j in seq(numOfDims)[seq(numOfDims)>i]){
print(seq(numOfDims-1))
print(seq(numOfDims)[seq(numOfDims)>i])
print(i)
print(j)
if (estimate_way == 'either'){
if (trueEdge[i,j] == TRUE){
if (estimate_edge[i,j] == FALSE & estimate_edge[j,i] == FALSE){
confusion$FN <- confusion$FN + 1
} else {
confusion$TP <- confusion$TP + 1
}
} else {
if (estimate_edge[i,j] == FALSE & estimate_edge[j,i] == FALSE){
confusion$TN <- confusion$TN + 1
} else {
confusion$FP <- confusion$FP + 1
}
}
} else if (estimate_way == 'both') {
if (trueEdge[i,j] == TRUE){
if (estimate_edge[i,j] == TRUE & estimate_edge[j,i] == TRUE){
confusion$TP <- confusion$TP + 1
} else {
confusion$FN <- confusion$FN + 1
}
} else {
if (estimate_edge[i,j] == TRUE & estimate_edge[j,i] == TRUE){
confusion$FP <- confusion$FP + 1
} else {
confusion$TN <- confusion$TN + 1
}
}
}
}
}
confusion$TP_rate <- confusion$TP/(confusion$TP + confusion$FN)
confusion$FP_rate <- confusion$FP/(confusion$FP + confusion$TN)
return(confusion)
}
table <- confusion_matrix(estimate_edge, true_edge, "either")
# This is the code for generating confusion matrix/ROC curve point based on given edtimated edge table and true edge table.
#
# Arguments:1. estimate_edge: the TRUE/FALSE table from edgetable.R
#           2. trueEdge: the TRUE/FALSE table from trueEdge.R
#           3. estimate_way: input 'both' or 'either' here. 'both' stands for E_1 estimator. 'either' stands for E_2 estimator.
#
# Retutn: 1.confusion: a list. Use list$TP/FP/FN/TN/TP_rate/FP_rate to get each confusion element or ROC curve point
#
confusion_matrix <- function(estimate_edge, trueEdge, estimate_way){
numOfDims <- nrow(estimate_edge)
confusion <- list(TP = 0,FP = 0,FN = 0,TN = 0,TP_rate = 0,FP_rate = 0)
for (i in seq(numOfDims-1)){
for (j in seq(numOfDims)[seq(numOfDims)>i]){
print(i)
print(j)
print(trueEdge[i,j])
if (estimate_way == 'either'){
if (trueEdge[i,j] == TRUE){
if (estimate_edge[i,j] == FALSE & estimate_edge[j,i] == FALSE){
confusion$FN <- confusion$FN + 1
} else {
confusion$TP <- confusion$TP + 1
}
} else {
if (estimate_edge[i,j] == FALSE & estimate_edge[j,i] == FALSE){
confusion$TN <- confusion$TN + 1
} else {
confusion$FP <- confusion$FP + 1
}
}
} else if (estimate_way == 'both') {
if (trueEdge[i,j] == TRUE){
if (estimate_edge[i,j] == TRUE & estimate_edge[j,i] == TRUE){
confusion$TP <- confusion$TP + 1
} else {
confusion$FN <- confusion$FN + 1
}
} else {
if (estimate_edge[i,j] == TRUE & estimate_edge[j,i] == TRUE){
confusion$FP <- confusion$FP + 1
} else {
confusion$TN <- confusion$TN + 1
}
}
}
}
}
confusion$TP_rate <- confusion$TP/(confusion$TP + confusion$FN)
confusion$FP_rate <- confusion$FP/(confusion$FP + confusion$TN)
return(confusion)
}
table <- confusion_matrix(estimate_edge, true_edge, "either")
print(trueEdge)
# This is the code for generating confusion matrix/ROC curve point based on given edtimated edge table and true edge table.
#
# Arguments:1. estimate_edge: the TRUE/FALSE table from edgetable.R
#           2. trueEdge: the TRUE/FALSE table from trueEdge.R
#           3. estimate_way: input 'both' or 'either' here. 'both' stands for E_1 estimator. 'either' stands for E_2 estimator.
#
# Retutn: 1.confusion: a list. Use list$TP/FP/FN/TN/TP_rate/FP_rate to get each confusion element or ROC curve point
#
confusion_matrix <- function(estimate_edge, trueEdge, estimate_way){
numOfDims <- nrow(estimate_edge)
confusion <- list(TP = 0,FP = 0,FN = 0,TN = 0,TP_rate = 0,FP_rate = 0)
for (i in seq(numOfDims-1)){
for (j in seq(numOfDims)[seq(numOfDims)>i]){
print(i)
print(j)
print(trueEdge)
if (estimate_way == 'either'){
if (trueEdge[i,j] == TRUE){
if (estimate_edge[i,j] == FALSE & estimate_edge[j,i] == FALSE){
confusion$FN <- confusion$FN + 1
} else {
confusion$TP <- confusion$TP + 1
}
} else {
if (estimate_edge[i,j] == FALSE & estimate_edge[j,i] == FALSE){
confusion$TN <- confusion$TN + 1
} else {
confusion$FP <- confusion$FP + 1
}
}
} else if (estimate_way == 'both') {
if (trueEdge[i,j] == TRUE){
if (estimate_edge[i,j] == TRUE & estimate_edge[j,i] == TRUE){
confusion$TP <- confusion$TP + 1
} else {
confusion$FN <- confusion$FN + 1
}
} else {
if (estimate_edge[i,j] == TRUE & estimate_edge[j,i] == TRUE){
confusion$FP <- confusion$FP + 1
} else {
confusion$TN <- confusion$TN + 1
}
}
}
}
}
confusion$TP_rate <- confusion$TP/(confusion$TP + confusion$FN)
confusion$FP_rate <- confusion$FP/(confusion$FP + confusion$TN)
return(confusion)
}
table <- confusion_matrix(estimate_edge, true_edge, "either")
table <- confusion_matrix(estimate_edge, trueedge, "either")
table
# This is the code for generating confusion matrix/ROC curve point based on given edtimated edge table and true edge table.
#
# Arguments:1. estimate_edge: the TRUE/FALSE table from edgetable.R
#           2. trueEdge: the TRUE/FALSE table from trueEdge.R
#           3. estimate_way: input 'both' or 'either' here. 'both' stands for E_1 estimator. 'either' stands for E_2 estimator.
#
# Retutn: 1.confusion: a list. Use list$TP/FP/FN/TN/TP_rate/FP_rate to get each confusion element or ROC curve point
#
confusion_matrix <- function(estimate_edge, trueEdge, estimate_way){
numOfDims <- nrow(estimate_edge)
confusion <- list(TP = 0,FP = 0,FN = 0,TN = 0,TP_rate = 0,FP_rate = 0)
for (i in seq(numOfDims)){
for (j in seq(numOfDims)[seq(numOfDims)>i]){
if (estimate_way == 'either'){
if (trueEdge[i,j] == TRUE){
if (estimate_edge[i,j] == FALSE & estimate_edge[j,i] == FALSE){
confusion$FN <- confusion$FN + 1
} else {
confusion$TP <- confusion$TP + 1
}
} else {
if (estimate_edge[i,j] == FALSE & estimate_edge[j,i] == FALSE){
confusion$TN <- confusion$TN + 1
} else {
confusion$FP <- confusion$FP + 1
}
}
} else if (estimate_way == 'both') {
if (trueEdge[i,j] == TRUE){
if (estimate_edge[i,j] == TRUE & estimate_edge[j,i] == TRUE){
confusion$TP <- confusion$TP + 1
} else {
confusion$FN <- confusion$FN + 1
}
} else {
if (estimate_edge[i,j] == TRUE & estimate_edge[j,i] == TRUE){
confusion$FP <- confusion$FP + 1
} else {
confusion$TN <- confusion$TN + 1
}
}
}
}
}
confusion$TP_rate <- confusion$TP/(confusion$TP + confusion$FN)
confusion$FP_rate <- confusion$FP/(confusion$FP + confusion$TN)
return(confusion)
}
table <- confusion_matrix(estimate_edge, trueedge, "either")
table
# This is the code for generating confusion matrix/ROC curve point based on given edtimated edge table and true edge table.
#
# Arguments:1. estimate_edge: the TRUE/FALSE table from edgetable.R
#           2. trueEdge: the TRUE/FALSE table from trueEdge.R
#           3. estimate_way: input 'both' or 'either' here. 'both' stands for E_1 estimator. 'either' stands for E_2 estimator.
#
# Retutn: 1.confusion: a list. Use list$TP/FP/FN/TN/TP_rate/FP_rate to get each confusion element or ROC curve point
#
confusion_matrix <- function(estimate_edge, trueEdge, estimate_way){
numOfDims <- nrow(estimate_edge)
confusion <- list(TP = 0,FP = 0,FN = 0,TN = 0,TP_rate = 0,FP_rate = 0)
for (i in seq(numOfDims-1)){
for (j in seq(numOfDims)[seq(numOfDims)>i]){
if (estimate_way == 'either'){
if (trueEdge[i,j] == TRUE){
if (estimate_edge[i,j] == FALSE & estimate_edge[j,i] == FALSE){
confusion$FN <- confusion$FN + 1
} else {
confusion$TP <- confusion$TP + 1
}
} else {
if (estimate_edge[i,j] == FALSE & estimate_edge[j,i] == FALSE){
confusion$TN <- confusion$TN + 1
} else {
confusion$FP <- confusion$FP + 1
}
}
} else if (estimate_way == 'both') {
if (trueEdge[i,j] == TRUE){
if (estimate_edge[i,j] == TRUE & estimate_edge[j,i] == TRUE){
confusion$TP <- confusion$TP + 1
} else {
confusion$FN <- confusion$FN + 1
}
} else {
if (estimate_edge[i,j] == TRUE & estimate_edge[j,i] == TRUE){
confusion$FP <- confusion$FP + 1
} else {
confusion$TN <- confusion$TN + 1
}
}
}
}
}
confusion$TP_rate <- confusion$TP/(confusion$TP + confusion$FN)
confusion$FP_rate <- confusion$FP/(confusion$FP + confusion$TN)
return(confusion)
}
testsample <- simulation(10,100)
testdata <- testsample$data
testtheta <-testsample$standardtheta
lambda_MINTESTERROR <- choose_best_lambda(testdata)
trueedge <- true_edge(testtheta)
estimate_edge <- edge_table(testdata, lambda_MINTESTERROR)
table <- confusion_matrix(estimate_edge, trueedge, "either")
table
roc <- ROC_curve(testdata, testtheta,"either",100)
ROC_curve <- function(data_set, theta, estimate_way, how_many_lambda_in_roc = 1000){
numOfDims <- ncol(data_set)
print(numOfDims)
max_lambda = 1
min_lambda = 0
points <- data.frame(matrix(ncol = 3, nrow = how_many_lambda_in_roc))
for (i in seq(numOfDims)){
y <- (data_set[,i])
x <- (data_set[,-c(i)])
lasso.train <-glmnet(x, y)
if (lasso.train$lambda[1]>max_lambda){
max_lambda <- lasso.train$lambda[1]
}
if (lasso.train$lambda[length(lasso.train$lambda)]<min_lambda){
min_lambda <- lasso.train$lambda[length(lasso.train$lambda)]
}
}
#print(max_lambda)
#print(min_lambda)
lambda_seq <- seq(from = min_lambda, to = max_lambda, length.out= how_many_lambda_in_roc)
#print(lambda_seq)
points[,3] <- lambda_seq
true_edge <- true_edge(theta)
for (i in seq(length(lambda_seq))){
estimate_edge <- edge_table(data_set, lambda_seq[i])
#print(estimate_edge)
confusion <- confusion_matrix(estimate_edge, true_edge, estimate_way)
#print(confusion)
TPR <- confusion$TP_rate
FPR <- confusion$FP_rate
#print(TPR)
#print(FPR)
points[i,1] <- TPR
points[i,2] <- FPR
}
colnames(points) <- c("TPR","FPR","Lambda")
return(points)
}
roc <- ROC_curve(testdata, testtheta,"either",100)
library(ggplot2)
ggplot(roc, aes(FPR, TPR)) + geom_step()
testsample <- simulation(100,1000)
testdata <- testsample$data
testtheta <-testsample$standardtheta
lambda_MINTESTERROR <- choose_best_lambda(testdata)
trueedge <- true_edge(testtheta)
estimate_edge <- edge_table(testdata, lambda_MINTESTERROR)
table <- confusion_matrix(estimate_edge, trueedge, "either")
table
roc <- ROC_curve(testdata, testtheta,"either",100)
ggplot(roc, aes(FPR, TPR)) + geom_step()
testsample <- simulation(10,1000)
testdata <- testsample$data
testtheta <-testsample$standardtheta
lambda_MINTESTERROR <- choose_best_lambda(testdata)
trueedge <- true_edge(testtheta)
estimate_edge <- edge_table(testdata, lambda_MINTESTERROR)
table <- confusion_matrix(estimate_edge, trueedge, "either")
table
roc <- ROC_curve(testdata, testtheta,"either",100)
ggplot(roc, aes(FPR, TPR)) + geom_step()
testsample <- simulation(5,1000)
testdata <- testsample$data
testtheta <-testsample$standardtheta
lambda_MINTESTERROR <- choose_best_lambda(testdata)
trueedge <- true_edge(testtheta)
estimate_edge <- edge_table(testdata, lambda_MINTESTERROR)
table <- confusion_matrix(estimate_edge, trueedge, "either")
table
roc <- ROC_curve(testdata, testtheta,"either",100)
library(ggplot2)
ggplot(roc, aes(FPR, TPR)) + geom_step()
roc <- ROC_curve(testdata, testtheta,"either",1000)
library(ggplot2)
ggplot(roc, aes(FPR, TPR)) + geom_step()
testsample <- simulation(50,1000)
testdata <- testsample$data
testtheta <-testsample$standardtheta
lambda_MINTESTERROR <- choose_best_lambda(testdata)
trueedge <- true_edge(testtheta)
estimate_edge <- edge_table(testdata, lambda_MINTESTERROR)
table <- confusion_matrix(estimate_edge, trueedge, "either")
table
roc <- ROC_curve(testdata, testtheta,"either",1000)
ggplot(roc, aes(FPR, TPR)) + geom_step()
testsample <- simulation(500,1000)
testdata <- testsample$data
testtheta <-testsample$standardtheta
lambda_MINTESTERROR <- choose_best_lambda(testdata)
trueedge <- true_edge(testtheta)
estimate_edge <- edge_table(testdata, lambda_MINTESTERROR)
table <- confusion_matrix(estimate_edge, trueedge, "either")
table
roc <- ROC_curve(testdata, testtheta,"either",100)
library(ggplot2)
ggplot(roc, aes(FPR, TPR)) + geom_step() + geom_point()
table
save.image("~/Documents/GitHub/ST443-Group-project/2.1-Node-wise-lasso/500x1000.RData")
